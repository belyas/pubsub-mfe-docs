import{_ as i,o as a,c as e,ag as n}from"./chunks/framework.CbQjVMS6.js";const c=JSON.parse('{"title":"Handler Isolation","description":"","frontmatter":{},"headers":[],"relativePath":"guide/handler-isolation.md","filePath":"guide/handler-isolation.md"}'),t={name:"guide/handler-isolation.md"};function l(r,s,h,o,p,d){return a(),e("div",null,[...s[0]||(s[0]=[n(`<h1 id="handler-isolation" tabindex="-1">Handler Isolation <a class="header-anchor" href="#handler-isolation" aria-label="Permalink to &quot;Handler Isolation&quot;">​</a></h1><p>One of PubSub MFE&#39;s core goals is to ensure that errors or slow handlers do not compromise the rest of the system. This page explains how handler isolation works and how to write resilient subscribers.</p><h2 id="what-is-handler-isolation" tabindex="-1">What is Handler Isolation? <a class="header-anchor" href="#what-is-handler-isolation" aria-label="Permalink to &quot;What is Handler Isolation?&quot;">​</a></h2><p>Handler isolation ensures that exceptions thrown by one subscriber do not prevent the bus from delivering a message to other subscribers. Each handler is invoked within a safe execution context.</p><h2 id="error-handling" tabindex="-1">Error Handling <a class="header-anchor" href="#error-handling" aria-label="Permalink to &quot;Error Handling&quot;">​</a></h2><ul><li>Exceptions thrown by a handler are caught by the bus and surfaced via diagnostics (if enabled) or logged to the console in development.</li><li>A failed handler does not interrupt delivery to other handlers.</li></ul><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bus.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">subscribe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;orders.process&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">msg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    processOrder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(msg.payload)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (err) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // local handler-level handling</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    reportError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(err, { topic: msg.topic })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><h2 id="timeouts-long-running-handlers" tabindex="-1">Timeouts &amp; Long-Running Handlers <a class="header-anchor" href="#timeouts-long-running-handlers" aria-label="Permalink to &quot;Timeouts &amp; Long-Running Handlers&quot;">​</a></h2><p>By design, handlers are executed synchronously for local delivery. If your handler can be long-running, consider:</p><ul><li>Offloading work to a microtask or worker:</li></ul><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bus.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">subscribe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;reports.generate&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">msg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // keep local delivery fast</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    heavyReportGeneration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(msg.payload)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><ul><li>Using promises and returning them if your adapter supports async handling.</li></ul><h2 id="isolation-patterns" tabindex="-1">Isolation Patterns <a class="header-anchor" href="#isolation-patterns" aria-label="Permalink to &quot;Isolation Patterns&quot;">​</a></h2><ul><li>Defensive coding: wrap sensitive logic in try/catch.</li><li>Use <code>AbortSignal</code> to cancel long-running subscriptions when components unmount.</li><li>Keep handlers focused and small — prefer delegating to services.</li></ul><h2 id="diagnostics-observability" tabindex="-1">Diagnostics &amp; Observability <a class="header-anchor" href="#diagnostics-observability" aria-label="Permalink to &quot;Diagnostics &amp; Observability&quot;">​</a></h2><p>Enable diagnostics via subscribing to the internal <code>bus.onDiagnostic</code> (if present) to collect handler exceptions, delivery times, and ordering.</p><h2 id="best-practices" tabindex="-1">Best Practices <a class="header-anchor" href="#best-practices" aria-label="Permalink to &quot;Best Practices&quot;">​</a></h2><ul><li>Do not mutate the incoming message payload directly — treat messages as immutable.</li><li>Avoid blocking the main thread in handlers. Move heavy CPU work to Web Workers or backend services.</li></ul><p>See also: <a href="/guide/advanced/performance.html">Performance</a> and <a href="/guide/topic-patterns.html">Topic Patterns</a>.</p>`,19)])])}const g=i(t,[["render",l]]);export{c as __pageData,g as default};
