{
  "version": 3,
  "sources": ["../../../src/topic-matcher.ts"],
  "sourcesContent": ["import type { TopicPattern, Topic, CompiledMatcher, MatcherSegment } from \"./types\";\n\nconst SEGMENT_DELIMITER = \".\";\nconst SINGLE_WILDCARD = \"+\";\nconst MULTI_WILDCARD = \"#\";\n// Cache for compiled matchers to avoid recompilation\nconst matcherCache = new Map<TopicPattern, CompiledMatcher>();\nconst MAX_CACHE_SIZE = 1000;\n\n/**\n * Compile a topic pattern into a matcher for efficient repeated matching.\n *\n * @param pattern - Topic pattern (e.g. \"cart.+.update\", \"cart.#\")\n *\n * @returns Compiled matcher object\n * @throws If pattern is invalid (e.g. # not at end, empty segments)\n */\nexport function compileMatcher(pattern: TopicPattern): CompiledMatcher {\n  const cached = matcherCache.get(pattern);\n\n  if (cached) {\n    return cached;\n  }\n\n  if (!pattern || typeof pattern !== \"string\") {\n    throw new Error(`Invalid topic pattern: ${pattern}.`);\n  }\n\n  const segments = splitTopic(pattern);\n  const matcherSegments: MatcherSegment[] = [];\n  let hasWildcards = false;\n\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n\n    // Empty segment check (e.g., \"cart..item\" or \".cart\")\n    if (segment === \"\") {\n      throw new Error(`Invalid topic pattern \"${pattern}\": empty segment at position ${i}.`);\n    }\n\n    if (segment === MULTI_WILDCARD) {\n      // # must be the last segment\n      if (i !== segments.length - 1) {\n        throw new Error(`Invalid topic pattern \"${pattern}\": # wildcard must be at the end.`);\n      }\n\n      hasWildcards = true;\n      matcherSegments.push({ type: \"multi\" });\n    } else if (segment === SINGLE_WILDCARD) {\n      hasWildcards = true;\n      matcherSegments.push({ type: \"single\" });\n    } else {\n      // Literal segment \u2014 validate characters (alphanumeric, hyphen, underscore)\n      if (!/^[a-zA-Z0-9_-]+$/.test(segment)) {\n        throw new Error(\n          `Invalid topic pattern \"${pattern}\": segment \"${segment}\" contains invalid characters. Use alphanumeric, hyphen, or underscore only.`\n        );\n      }\n\n      matcherSegments.push({ type: \"literal\", value: segment });\n    }\n  }\n\n  const matcher: CompiledMatcher = {\n    pattern,\n    hasWildcards,\n    segments: matcherSegments,\n  };\n\n  if (matcherCache.size >= MAX_CACHE_SIZE) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const firstKey = matcherCache.keys().next().value!;\n    matcherCache.delete(firstKey);\n  }\n\n  matcherCache.set(pattern, matcher);\n\n  return matcher;\n}\n\n/**\n * Test if a topic matches a compiled pattern using segment-by-segment comparison.\n * Uses a Trie-like algorithm without regex overhead.\n *\n * @param topic - Topic to match\n * @param matcher - Compiled matcher from compileMatcher()\n *\n * @returns true if topic matches the pattern\n */\nexport function matchTopic(topic: Topic, matcher: CompiledMatcher): boolean {\n  if (!matcher.hasWildcards) {\n    return topic === matcher.pattern;\n  }\n\n  // Trie-based segment matching for wildcard patterns\n  const topicSegments = splitTopic(topic);\n\n  if (topicSegments.some((seg) => seg === \"\")) {\n    // Topics with empty segments cannot match wildcard patterns\n    return false;\n  }\n\n  const patternSegments = matcher.segments;\n\n  return matchSegments(topicSegments, 0, patternSegments, 0);\n}\n\n/**\n * Recursive segment-by-segment matching.\n * Handles +, #, and literal segments.\n */\nfunction matchSegments(\n  topicSegments: string[],\n  topicIndex: number,\n  patternSegments: MatcherSegment[],\n  patternIndex: number\n): boolean {\n  if (patternIndex >= patternSegments.length) {\n    return topicIndex >= topicSegments.length;\n  }\n\n  const patternSegment = patternSegments[patternIndex];\n\n  switch (patternSegment.type) {\n    case \"multi\":\n      // # matches zero or more remaining segments\n      // Since # must be last, we're done\n      return true;\n\n    case \"single\":\n      // + matches exactly one segment\n      if (topicIndex >= topicSegments.length) {\n        return false;\n      }\n      return matchSegments(topicSegments, topicIndex + 1, patternSegments, patternIndex + 1);\n\n    case \"literal\":\n      // Literal must match exactly\n      if (topicIndex >= topicSegments.length) {\n        return false;\n      }\n      if (topicSegments[topicIndex] !== patternSegment.value) {\n        return false;\n      }\n      return matchSegments(topicSegments, topicIndex + 1, patternSegments, patternIndex + 1);\n  }\n}\n\n/**\n * Validate a publish topic (exact topic, no wildcards).\n *\n * @param topic - Topic to validate\n *\n * @throws If topic contains wildcards or invalid characters\n */\nexport function validatePublishTopic(topic: Topic): void {\n  if (!topic || typeof topic !== \"string\") {\n    throw new Error(`Invalid topic: ${topic || \"empty\"}.`);\n  }\n\n  if (topic.includes(SINGLE_WILDCARD) || topic.includes(MULTI_WILDCARD)) {\n    throw new Error(\n      `Invalid publish topic \"${topic}\": wildcards (+ or #) are not allowed in publish topics. Use exact topic names for publishing.`\n    );\n  }\n\n  const segments = splitTopic(topic);\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n\n    if (segment === \"\") {\n      throw new Error(`Invalid topic \"${topic}\": empty segment at position ${i}`);\n    }\n\n    if (!/^[a-zA-Z0-9_-]+$/.test(segment)) {\n      throw new Error(\n        `Invalid topic \"${topic}\": segment \"${segment}\" contains invalid characters. Use alphanumeric, hyphen, or underscore only.`\n      );\n    }\n  }\n}\n\n/**\n * Split a topic into segments.\n */\nexport function splitTopic(topic: Topic): string[] {\n  return topic.split(SEGMENT_DELIMITER);\n}\n\n/**\n * Join segments into a topic.\n */\nexport function joinTopic(...segments: string[]): Topic {\n  return segments.join(SEGMENT_DELIMITER);\n}\n\n/**\n * Clear the matcher cache.\n * Useful for testing or when patterns change.\n */\nexport function clearMatcherCache(): void {\n  matcherCache.clear();\n}\n\n/**\n * Get the size of the matcher cache.\n * Useful for diagnostics.\n */\nexport function getMatcherCacheSize(): number {\n  return matcherCache.size;\n}\n\n/**\n * Get the matcher cache map.\n * Useful for testing or diagnostics.\n */\nexport function getCache() {\n  return matcherCache;\n}\n"],
  "mappings": "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",
  "names": []
}
